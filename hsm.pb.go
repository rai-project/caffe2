// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hsm.proto

package caffe2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Each node in the hierarchy contains links to either leaf nodes or more
// non-terminal nodes
type NodeProto struct {
	// Links to non-terminal children nodes
	Children []*NodeProto `protobuf:"bytes,1,rep,name=children" json:"children,omitempty"`
	// Links to terminal (leaf) nodes
	WordIds []int32   `protobuf:"varint,2,rep,name=word_ids,json=wordIds" json:"word_ids,omitempty"`
	Offset  int32     `protobuf:"varint,3,opt,name=offset" json:"offset"`
	Name    string    `protobuf:"bytes,4,opt,name=name" json:"name"`
	Scores  []float32 `protobuf:"fixed32,5,rep,name=scores" json:"scores,omitempty"`
}

func (m *NodeProto) Reset()         { *m = NodeProto{} }
func (m *NodeProto) String() string { return proto.CompactTextString(m) }
func (*NodeProto) ProtoMessage()    {}
func (*NodeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_hsm_1f3a0dd4b5f0b945, []int{0}
}
func (m *NodeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NodeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeProto.Merge(dst, src)
}
func (m *NodeProto) XXX_Size() int {
	return m.Size()
}
func (m *NodeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeProto.DiscardUnknown(m)
}

var xxx_messageInfo_NodeProto proto.InternalMessageInfo

func (m *NodeProto) GetChildren() []*NodeProto {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *NodeProto) GetWordIds() []int32 {
	if m != nil {
		return m.WordIds
	}
	return nil
}

func (m *NodeProto) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *NodeProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeProto) GetScores() []float32 {
	if m != nil {
		return m.Scores
	}
	return nil
}

// Protobuf format to accept hierarchy for hierarchical softmax operator.
// TreeProto points to the root node.
type TreeProto struct {
	RootNode *NodeProto `protobuf:"bytes,1,opt,name=root_node,json=rootNode" json:"root_node,omitempty"`
}

func (m *TreeProto) Reset()         { *m = TreeProto{} }
func (m *TreeProto) String() string { return proto.CompactTextString(m) }
func (*TreeProto) ProtoMessage()    {}
func (*TreeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_hsm_1f3a0dd4b5f0b945, []int{1}
}
func (m *TreeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TreeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreeProto.Merge(dst, src)
}
func (m *TreeProto) XXX_Size() int {
	return m.Size()
}
func (m *TreeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TreeProto.DiscardUnknown(m)
}

var xxx_messageInfo_TreeProto proto.InternalMessageInfo

func (m *TreeProto) GetRootNode() *NodeProto {
	if m != nil {
		return m.RootNode
	}
	return nil
}

// Internal Protobuf format which represents the path in the tree hierarchy for
// each word in the vocabulary.
type HierarchyProto struct {
	Size_ int32        `protobuf:"varint,1,opt,name=size" json:"size"`
	Paths []*PathProto `protobuf:"bytes,2,rep,name=paths" json:"paths,omitempty"`
}

func (m *HierarchyProto) Reset()         { *m = HierarchyProto{} }
func (m *HierarchyProto) String() string { return proto.CompactTextString(m) }
func (*HierarchyProto) ProtoMessage()    {}
func (*HierarchyProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_hsm_1f3a0dd4b5f0b945, []int{2}
}
func (m *HierarchyProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HierarchyProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HierarchyProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HierarchyProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HierarchyProto.Merge(dst, src)
}
func (m *HierarchyProto) XXX_Size() int {
	return m.Size()
}
func (m *HierarchyProto) XXX_DiscardUnknown() {
	xxx_messageInfo_HierarchyProto.DiscardUnknown(m)
}

var xxx_messageInfo_HierarchyProto proto.InternalMessageInfo

func (m *HierarchyProto) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *HierarchyProto) GetPaths() []*PathProto {
	if m != nil {
		return m.Paths
	}
	return nil
}

// Each PathProto belongs to a word and is an array of nodes in the
// path from the root to the leaf (which is the word itself) in the tree.
type PathProto struct {
	WordId    int32            `protobuf:"varint,1,opt,name=word_id,json=wordId" json:"word_id"`
	PathNodes []*PathNodeProto `protobuf:"bytes,2,rep,name=path_nodes,json=pathNodes" json:"path_nodes,omitempty"`
}

func (m *PathProto) Reset()         { *m = PathProto{} }
func (m *PathProto) String() string { return proto.CompactTextString(m) }
func (*PathProto) ProtoMessage()    {}
func (*PathProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_hsm_1f3a0dd4b5f0b945, []int{3}
}
func (m *PathProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PathProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathProto.Merge(dst, src)
}
func (m *PathProto) XXX_Size() int {
	return m.Size()
}
func (m *PathProto) XXX_DiscardUnknown() {
	xxx_messageInfo_PathProto.DiscardUnknown(m)
}

var xxx_messageInfo_PathProto proto.InternalMessageInfo

func (m *PathProto) GetWordId() int32 {
	if m != nil {
		return m.WordId
	}
	return 0
}

func (m *PathProto) GetPathNodes() []*PathNodeProto {
	if m != nil {
		return m.PathNodes
	}
	return nil
}

// Represents a node in the path from the root node all the way down to the
// word (leaf).
type PathNodeProto struct {
	// Parameter matrix offset for this node
	Index int32 `protobuf:"varint,1,opt,name=index" json:"index"`
	// Number of children
	Length int32 `protobuf:"varint,2,opt,name=length" json:"length"`
	// Index of the next node in the path
	Target int32 `protobuf:"varint,3,opt,name=target" json:"target"`
}

func (m *PathNodeProto) Reset()         { *m = PathNodeProto{} }
func (m *PathNodeProto) String() string { return proto.CompactTextString(m) }
func (*PathNodeProto) ProtoMessage()    {}
func (*PathNodeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_hsm_1f3a0dd4b5f0b945, []int{4}
}
func (m *PathNodeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathNodeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathNodeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PathNodeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathNodeProto.Merge(dst, src)
}
func (m *PathNodeProto) XXX_Size() int {
	return m.Size()
}
func (m *PathNodeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_PathNodeProto.DiscardUnknown(m)
}

var xxx_messageInfo_PathNodeProto proto.InternalMessageInfo

func (m *PathNodeProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PathNodeProto) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *PathNodeProto) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func init() {
	proto.RegisterType((*NodeProto)(nil), "caffe2.NodeProto")
	proto.RegisterType((*TreeProto)(nil), "caffe2.TreeProto")
	proto.RegisterType((*HierarchyProto)(nil), "caffe2.HierarchyProto")
	proto.RegisterType((*PathProto)(nil), "caffe2.PathProto")
	proto.RegisterType((*PathNodeProto)(nil), "caffe2.PathNodeProto")
}
func (m *NodeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHsm(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WordIds) > 0 {
		for _, num := range m.WordIds {
			dAtA[i] = 0x10
			i++
			i = encodeVarintHsm(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintHsm(dAtA, i, uint64(m.Offset))
	dAtA[i] = 0x22
	i++
	i = encodeVarintHsm(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Scores) > 0 {
		for _, num := range m.Scores {
			dAtA[i] = 0x2d
			i++
			f1 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
			i += 4
		}
	}
	return i, nil
}

func (m *TreeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RootNode != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHsm(dAtA, i, uint64(m.RootNode.Size()))
		n2, err := m.RootNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *HierarchyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HierarchyProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintHsm(dAtA, i, uint64(m.Size_))
	if len(m.Paths) > 0 {
		for _, msg := range m.Paths {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHsm(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PathProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintHsm(dAtA, i, uint64(m.WordId))
	if len(m.PathNodes) > 0 {
		for _, msg := range m.PathNodes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHsm(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PathNodeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathNodeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintHsm(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x10
	i++
	i = encodeVarintHsm(dAtA, i, uint64(m.Length))
	dAtA[i] = 0x18
	i++
	i = encodeVarintHsm(dAtA, i, uint64(m.Target))
	return i, nil
}

func encodeVarintHsm(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NodeProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovHsm(uint64(l))
		}
	}
	if len(m.WordIds) > 0 {
		for _, e := range m.WordIds {
			n += 1 + sovHsm(uint64(e))
		}
	}
	n += 1 + sovHsm(uint64(m.Offset))
	l = len(m.Name)
	n += 1 + l + sovHsm(uint64(l))
	if len(m.Scores) > 0 {
		n += 5 * len(m.Scores)
	}
	return n
}

func (m *TreeProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RootNode != nil {
		l = m.RootNode.Size()
		n += 1 + l + sovHsm(uint64(l))
	}
	return n
}

func (m *HierarchyProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovHsm(uint64(m.Size_))
	if len(m.Paths) > 0 {
		for _, e := range m.Paths {
			l = e.Size()
			n += 1 + l + sovHsm(uint64(l))
		}
	}
	return n
}

func (m *PathProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovHsm(uint64(m.WordId))
	if len(m.PathNodes) > 0 {
		for _, e := range m.PathNodes {
			l = e.Size()
			n += 1 + l + sovHsm(uint64(l))
		}
	}
	return n
}

func (m *PathNodeProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovHsm(uint64(m.Index))
	n += 1 + sovHsm(uint64(m.Length))
	n += 1 + sovHsm(uint64(m.Target))
	return n
}

func sovHsm(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHsm(x uint64) (n int) {
	return sovHsm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &NodeProto{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WordIds = append(m.WordIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WordIds) == 0 {
					m.WordIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WordIds = append(m.WordIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WordIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Scores = append(m.Scores, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Scores) == 0 {
					m.Scores = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Scores = append(m.Scores, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Scores", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RootNode == nil {
				m.RootNode = &NodeProto{}
			}
			if err := m.RootNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HierarchyProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HierarchyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HierarchyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, &PathProto{})
			if err := m.Paths[len(m.Paths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WordId", wireType)
			}
			m.WordId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WordId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathNodes = append(m.PathNodes, &PathNodeProto{})
			if err := m.PathNodes[len(m.PathNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathNodeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathNodeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathNodeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHsm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHsm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHsm
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHsm
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHsm(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHsm = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHsm   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("hsm.proto", fileDescriptor_hsm_1f3a0dd4b5f0b945) }

var fileDescriptor_hsm_1f3a0dd4b5f0b945 = []byte{
	// 343 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xbd, 0x4e, 0xc3, 0x30,
	0x14, 0x85, 0xe3, 0xe6, 0xa7, 0xf5, 0x45, 0x20, 0x61, 0x09, 0x64, 0x10, 0x84, 0x28, 0x0b, 0x59,
	0xc8, 0x50, 0xb1, 0xb1, 0x75, 0x82, 0x05, 0x55, 0x81, 0xbd, 0x44, 0xb1, 0xd3, 0x44, 0x6a, 0xe3,
	0xca, 0xb6, 0xc4, 0xcf, 0x53, 0xf0, 0x12, 0xbc, 0x4b, 0xc7, 0x8e, 0x4c, 0x08, 0xb5, 0x2f, 0x82,
	0x12, 0xa7, 0xa5, 0x45, 0x62, 0xbc, 0xdf, 0x39, 0xf7, 0xe4, 0xe4, 0x1a, 0x70, 0xa1, 0xa6, 0xf1,
	0x4c, 0x0a, 0x2d, 0x88, 0x97, 0xa5, 0x79, 0xce, 0xfb, 0xe1, 0x07, 0x02, 0x7c, 0x2f, 0x18, 0x1f,
	0x36, 0xf4, 0x0a, 0x7a, 0x59, 0x51, 0x4e, 0x98, 0xe4, 0x15, 0x45, 0x81, 0x1d, 0xed, 0xf5, 0x0f,
	0x63, 0x63, 0x8c, 0x37, 0xa6, 0x64, 0x63, 0x21, 0x27, 0xd0, 0x7b, 0x16, 0x92, 0x8d, 0x4a, 0xa6,
	0x68, 0x27, 0xb0, 0x23, 0x37, 0xe9, 0xd6, 0xf3, 0x1d, 0x53, 0xe4, 0x0c, 0x3c, 0x91, 0xe7, 0x8a,
	0x6b, 0x6a, 0x07, 0x28, 0x72, 0x07, 0xce, 0xfc, 0xeb, 0xc2, 0x4a, 0x5a, 0x46, 0x28, 0x38, 0x55,
	0x3a, 0xe5, 0xd4, 0x09, 0x50, 0x84, 0x5b, 0xad, 0x21, 0xe4, 0x18, 0x3c, 0x95, 0x09, 0xc9, 0x15,
	0x75, 0x03, 0x3b, 0xea, 0x24, 0xed, 0x14, 0xde, 0x00, 0x7e, 0x94, 0xbc, 0xad, 0x19, 0x03, 0x96,
	0x42, 0xe8, 0x51, 0x25, 0x18, 0xa7, 0x28, 0x40, 0xff, 0xf4, 0xac, 0x3d, 0xf5, 0x18, 0x3e, 0xc0,
	0xc1, 0x6d, 0xc9, 0x65, 0x2a, 0xb3, 0xe2, 0xd5, 0x24, 0x50, 0x70, 0x54, 0xf9, 0x66, 0x96, 0xd7,
	0xe5, 0x1a, 0x42, 0x2e, 0xc1, 0x9d, 0xa5, 0xba, 0x30, 0x3f, 0xb4, 0x95, 0x3b, 0x4c, 0x75, 0x61,
	0x72, 0x8d, 0x1e, 0x3e, 0x01, 0xde, 0x30, 0x72, 0x0e, 0xdd, 0xf6, 0x12, 0x3b, 0x91, 0x9e, 0x39,
	0x07, 0xb9, 0x06, 0xa8, 0x97, 0x9a, 0xc2, 0xeb, 0xe4, 0xa3, 0xed, 0xe4, 0xdf, 0xd6, 0x78, 0xd6,
	0x8e, 0x2a, 0x1c, 0xc3, 0xfe, 0x8e, 0x46, 0x4e, 0xc1, 0x2d, 0x2b, 0xc6, 0x5f, 0x76, 0xbe, 0x61,
	0x50, 0x7d, 0xf0, 0x09, 0xaf, 0xc6, 0xba, 0xa0, 0x9d, 0xed, 0x02, 0x86, 0xd5, 0xaa, 0x4e, 0xe5,
	0xf8, 0xef, 0x73, 0x18, 0x36, 0xa0, 0xf3, 0xa5, 0x8f, 0x16, 0x4b, 0x1f, 0x7d, 0x2f, 0x7d, 0xf4,
	0xbe, 0xf2, 0xad, 0xc5, 0xca, 0xb7, 0x3e, 0x57, 0xbe, 0xf5, 0x13, 0x00, 0x00, 0xff, 0xff, 0x6d,
	0x8b, 0xa1, 0xc6, 0x32, 0x02, 0x00, 0x00,
}
